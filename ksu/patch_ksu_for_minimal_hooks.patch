diff --git a/kernel/ksud.c b/kernel/ksud.c
index ae336a13..3761b6ce 100644
--- a/kernel/ksud.c
+++ b/kernel/ksud.c
@@ -506,6 +506,34 @@ __maybe_unused int ksu_handle_execve_ksud(const char __user *filename_user,
 	return ksu_handle_execveat_ksud(AT_FDCWD, &filename_p, &argv, NULL, NULL);
 }
 
+#if defined(CONFIG_64BIT) && defined(CONFIG_COMPAT)
+__maybe_unused int ksu_handle_compat_execve_ksud(const char __user *filename_user,
+			const compat_uptr_t __user *__argv)
+{
+	struct user_arg_ptr argv = { .ptr.compat = __argv };
+	struct filename filename_in, *filename_p;
+	char path[32];
+
+	// return early if disabled.
+	if (!ksu_execveat_hook) {
+		return 0;
+	}
+
+	if (!filename_user)
+		return 0;
+
+	memset(path, 0, sizeof(path));
+	ksu_strncpy_from_user_nofault(path, filename_user, 32);
+
+	// this is because ksu_handle_execveat_ksud calls it filename->name
+	filename_in.name = path;
+	filename_p = &filename_in;
+    
+	return ksu_handle_execveat_ksud(AT_FDCWD, &filename_p, &argv, NULL, NULL);
+}
+#endif
+
+
 #ifdef CONFIG_KSU_KPROBES_HOOK
 
 // https://elixir.bootlin.com/linux/v5.10.158/source/fs/exec.c#L1864
diff --git a/kernel/sucompat.c b/kernel/sucompat.c
index 11b2a551..81d3a545 100644
--- a/kernel/sucompat.c
+++ b/kernel/sucompat.c
@@ -69,8 +69,23 @@ int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode,
 	}
 
 	char path[sizeof(su) + 1];
-	memset(path, 0, sizeof(path));
-	ksu_strncpy_from_user_nofault(path, *filename_user, sizeof(path));
+	// nofault variant fails probably due to pagefault_disable
+	// some cpus dont really have that good speculative execution
+	// substitute set_fs, check if pointer is valid
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+	if (!access_ok(VERIFY_READ, *filename_user, sizeof(path)))
+		return 0;
+#else
+	if (!access_ok(*filename_user, sizeof(path)))
+		return 0;
+#endif
+	// success = returns number of bytes and should be less than path
+	long len = strncpy_from_user(path, *filename_user, sizeof(path));
+	if (len <= 0 || len > sizeof(path))
+		return 0;
+
+	// strncpy_from_user_nofault does this too
+	path[sizeof(path) - 1] = '\0';
 
 	if (unlikely(!memcmp(path, su, sizeof(su)))) {
 		pr_info("faccessat su->sh!\n");
